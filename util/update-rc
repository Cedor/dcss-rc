#!/usr/bin/env python3

"""
Using a single rc file, update a set of DCSS games (versions) on a set of
WebTiles servers over WebSockets. Default locations for rc files are ~/.crawlrc
and ~/.crawl/init.txt

"""

import argparse
import asyncio
import getpass
import json
import logging
import os
import os.path
import re
import sys
import time
import websockets
import zlib

class update_error(Exception):
    def __init__(self, msg):
        self.msg = msg
        super(update_error, self).__init__(msg)

class update_rc:

    def __init__(self, websocket_url, update_games, username, password,
                 rc_text):
        self.websocket_url = websocket_url
        self.update_games = update_games
        self.username = username
        self.password = password
        self.rc_text = rc_text
        self.messages = []
        self.found_games = []
        self.decomp = zlib.decompressobj(-zlib.MAX_WBITS)

    @asyncio.coroutine
    def start(self):
        yield from self.connect()
        yield from self.connection_handler()

    @asyncio.coroutine
    def connect(self):
        self.websocket = yield from websockets.connect(self.websocket_url)
        self.messages.append({"msg" : "login",
                              "username" : self.username,
                              "password" : self.password})

    @asyncio.coroutine
    def disconnect(self):
        yield from self.websocket.close()

    @asyncio.coroutine
    def send_message(self):
        if not len(self.messages) or not self.websocket.open:
            return

        message = self.messages.pop(0)
        yield from self.websocket.send(json.dumps(message))

    def update_rcs(self, message):
        game_pattern = r'<a href="#play-([^"]+)">([^>]+)</a>'
        for m in re.finditer(game_pattern, message["content"]):
            game_id = m.group(1)
            game_name = m.group(2)

            do_update = False
            for g in self.update_games:
                ## Need a better way to match this
                if re.search("DCSS.*" + g, game_name, flags=re.IGNORECASE):
                    do_update = True
                    self.found_games.append(g)
                    break

            if do_update:
                data = {"msg" : "set_rc",
                        "game_id" : game_id,
                        "contents" : rc_text}
                self.messages.append(data)
                log.info("Sending update for game {}.".format(g))

        if len(self.found_games) != len(self.update_games):
            games_list = ", ".join(self.update_games)
            game_desc =  "None"
            if len(self.found_games):
                game_desc = ",".join(self.found_games)
            raise update_error("Requested games: {0}; Found games: "
                               "{1}".format(games_list, game_desc))

    def handle_message(self, message):
        if message["msg"] == "ping":
            response = {"msg" : "pong"}
            self.messages.append(response)
        elif message["msg"] == "login_success":
            log.debug("Login successful")
        elif message["msg"] == "set_game_links":
            if "content" not in message:
                raise update_error("Invalid set_game_links message: "
                                   "{}".format(json.dumps(message)))
            else:
                self.update_rcs(message)
        elif message["msg"] == "login_fail":
            raise update_error("Login failed.")

    @asyncio.coroutine
    def receive_messages(self):
        if not self.websocket.open:
            return

        comp_data = yield from self.websocket.recv()
        if comp_data is None:
            return

        comp_data += bytes([0, 0, 255, 255])
        json_message = self.decomp.decompress(comp_data)
        json_message = json_message.decode("utf-8")

        if json_message is None:
            raise update_error("Empty WebSocket message.")

        message = json.loads(json_message)
        result = None
        if "msgs" in message:
            messages = message["msgs"]
        elif "msg" in message:
            messages = [message]
        else:
            raise update_error("Invalid WebSocket message.")

        for m in messages:
            self.handle_message(m)

    @asyncio.coroutine
    def connection_handler(self):
        webtiles_listen = None
        webtiles_send = None
        while True:
            tasks = []
            if not webtiles_listen:
                webtiles_listen = asyncio.async(self.receive_messages())
            tasks.append(webtiles_listen)

            if not webtiles_send and len(self.messages):
                webtiles_send = asyncio.async(self.send_message())
            if webtiles_send:
                tasks.append(webtiles_send)

            done, pending = yield from asyncio.wait(
                tasks, return_when=asyncio.FIRST_COMPLETED)

            if webtiles_listen in done:
                webtiles_listen = None

            if webtiles_send in done:
                webtiles_send = None

            if (len(self.messages) == 0
                and len(self.found_games) == len(self.update_games)):
                log.info("All rcs updated; closing connection.")
                yield from self.disconnect()
                return
            elif not self.websocket.open:
                raise update_error("WebSocket was closed.")


if __name__ == '__main__':
    servers = {"cszo" : "ws://crawl.s-z.org/socket",
               "cao"  : "ws://crawl.akrasiac.org:8080/socket",
               "cbro" : "ws://crawl.berotato.org:8080/socket",
               "cxc"  : "ws://crawl.xtahua.com:8080/socket",
               "cue"  : "ws://www.underhound.eu:8080/socket",
               "lld"  : "ws://lazy-life.ddo.jp:8080/socket",
               "cwz"  : "ws://webzook.net:8080/socket"}
    server_codes = ", ".join(sorted(servers.keys()))
    games = ["trunk", "0.16"]

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("servers", nargs='+', metavar="<server>",
                        help="Server to update, one of: " + server_codes)
    parser.add_argument("-f", dest="rc_file", nargs=1, metavar="<rc-file>",
                        default=None, help="The rc file to use.")
    parser.add_argument("-u", dest="username", metavar="<username>",
                        help="The account username.", default=None)
    parser.add_argument("-p", dest="password", metavar="<password>",
                        help="The account password.", default=None)
    parser.add_argument("-g", dest="games", metavar="<game1>[,<game2>,...]",
                        help="Comma-seperated list of games to update."
                        "(default: %(default)s).", default=",".join(games))
    args = parser.parse_args()

    rc_file = args.rc_file
    if rc_file is None:
        if os.path.isfile(os.environ["HOME"] + "/.crawl/init.txt"):
            rc_file = os.environ["HOME"] + "/.crawl/init.txt"
        elif os.path.isfile(os.environ["HOME"] + "/.crawlrc"):
            rc_file = os.environ["HOME"] + "/.crawlrc"
        else:
            sys.exit("No crawl rc found and none given with -f")

    update_servers = args.servers
    for s in update_servers:
        if s not in servers:
            sys.exit("Unrecognized server: " + s)

    update_games = args.games.split(",")
    for g in update_games:
        if g not in games:
            sys.exit("Unrecognized game: " + g)

    rc_fh = open(rc_file, "rU")
    rc_text = rc_fh.read()

    username = args.username
    if not username:
        username = input("Crawl username: ")

    password = args.password
    if not password:
        password = getpass.getpass("Crawl password: ")

    log = logging.getLogger()
    logging.basicConfig(stream=sys.stdout, level=logging.INFO)
    log.info("Update user %s with %d bytes from file %s", username,
             len(rc_text), rc_file)
    for s in update_servers:
        print("Updating server " + s)
        updater = update_rc(servers[s], update_games, username, password,
                            rc_text)
        try:
            asyncio.get_event_loop().run_until_complete(updater.start())
        except update_error as e:
            log.error(e.msg)
            updater.disconnect()
            sys.exit(1)
